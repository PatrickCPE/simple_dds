#+title: Simple DDS Specification
#+author: Patrick Hoey
#+email: patrickrhoey@gmail.com
#+date: 2022-11-28
#+description: A small DDS core capable of generating sin or arbitrary waves based upon configuration.

#+OPTIONS: ^:nil

-----
* Overview
Simple DDS Specification

Author: Patrick Hoey

Email: patrickrhoey@gmail.com

Date: 2022-10-30

Revision: 0.1

Description:
DDS (Direct Digital Synthesis) core capable of waveform generation. The core has a Wishbone B4 Classic bus interface.
-----
* Architecture
#+caption: Simple DDS Block Diagram
[[file:simple_dds.png]]
-----
* TODO Operation
A Direct Digital Synthesizer (DDS) is a method of generating a variable frequency waveform via a digital method. It operates via a tuning word, an input clock, a phase accumulator, and a look up table(LUT).

The DDS core has a pointer(the phase accumulator) that will reference a location in one of the LUTs. This LUT contains the data for a waveform (for example the values of Sine).
Your tuning word is a measure of how many addresses to increment every time your DDS clock edge occurs(overflow returns you to the start of the LUT).
Therefore your DDS will iterate through the LUT faster with a higher valued tuning word based, at the cost of hitting less values.

#+caption: Phase accumulator diagram
[[file:phase_acccumulator.png]]

Therein is your trade-off with a DDS. You can iterate through the waveform shape slowly with very high precision and a slow output frequency, or iterate through it quickly with less precision and a high output frequency. 

| variable       | description                                                      |
| $f_{out}$      | output frequency of your signal                                  |
| M              | Tuning word value (Magnitude of jumps on your phase accumulator) |
| $f_{dds\_clk}$ | Frequency of your input clock to the DDS core                    |
| n              | Width of your phase accumulator                                  |

$f_{out} = {{M * f_{dds\_clk}} / 2^n}$

This particular core has 4 LUTs you can iterate through. A sine wave, a sawtooth wave, a random wave(which isn't truly a LUT), and a user defined wave that you can program into RAM via the interface. \
There is also a gain and offset register that the user can program to modify the output signal. The output signal pipes directly into a DAC to create your waveform.

This core communicates with external IP via a Wishbone B4 Classic Bus. See references to access the specification.

#+caption: Reset Sequence
[[file:reset_seq.png]]
Reset must be asserted for at least one clock cycle. It may be asserted any length of clock cycles.

#+caption: Read Sequence
[[file:read_seq.png]]
wb_stb_i, wb_we_i, and wb_addr_i must be ready before the rising edge of wb_clk_i.
wb_dat_o and wb_ack will become valid some time before the next bclk edge and will remain valid for one clock.


#+caption: Write Sequence
[[file:write_seq.png]]

TODO write picture and explanation
-----
* Registers and Memory
** Registers
| register name | register address | Bit Map                                | R/W | Description                                                                          | Initial Value |
| ready         |            0x000 | {[31:1] reserved, [0] ready}           | R   | Will assert high once core can begin operation following a reset                     |    0x00000000 |
| enable        |            0x001 | {[31:1] reserved, [0] enable}          | R/W | Enables DDS operation once written. Ready must be high before you can write to this  |    0x00000000 |
| dds_src       |            0x002 | {[31:2] reserved, [1:0] dds_src}       | R/W | Indicates the source of the dds signal. 0=Sine, 1=Sawtooth, 2 = Triangle, 3=Random   |    0x00000000 |
| tuning_word   |            0x003 | {[31:8] reserved, [7:0] tuning_word}   | R/W | Tuning word for the DDS phase accumulator                                            |    0x00000001 |
| gain_word     |            0x004 | {[31:2] reserved, [1:0] gain_word}     | R/W | Multiplier for gain. Gain is a multiple of 2 so setting gain_word = 0x3 -> 2^3 -> x8 |    0x00000000 |
| offset_word   |            0x005 | {31:16} reserved, [15:0] offset_word   | R/W | Offset to be added to the result.                                                    |    0x00007FFF |
# TODO add seed register and determine seed width

-----
** Memory
| memory region | region lower bound | region upper bound | Data Width | R/W | Description                                                               |
| RAM           |              0x400 |              0x4FF |          8 | R/W | User memory area. 256 8-bit memory cells to store user defined waveforms |

When reading or writing from the memory areas only the lower 7 bits of the wishbone data output signal will be utilized due to the 8 bit data widths. Please note that these cells are not reset to a value.

Garbage Data will be in them on before they have been written to.
** LUTs
| LUT      | LUT Width | LUT Data Width | Data Width |Description                                 |
| Sine     |       256 |              8 |          8 | Sine look up table used by the DDS core    |
| Sawtooth |       256 |              8 |          8 | Sawtooth look up table used by the DDS core |
-----
* Clocks
The following clocks are present within the design.
| clock name | clock description                                                               | Clock max frequency |
| wb_clk_i   | Wishbone B4 Classic bus clock input                                             | Process Dependent   |
| dds_clk_i  | Input to the DDS core itself. The frequency at which the phase acumulator jumps | Process Dependent   |

Clock speeds will depend upon the specific cell library or FPGA this design processes.
-----
* IO Ports
Wishbone interface uses the Wishbone B4 Classic slave interface. The optional features select, error, and retry are not supported on the bus. With the exclusion of select all data transfers are 32-bit.
| port name | port width | description                                                                                        |
| wb_clk_i  |          1 | Input clock to the core                                                                            |
| wb_rst_i  |          1 | Reset for the core                                                                                 |
| wb_dat_i  |         32 | 32-bit data input to the core                                                                      |
| wb_addr_i |         12 | Indicates a valid bus cycle is in progress. Remains asserted for multi clock bus transactions      |
| wb_we_i   |          1 | Indicates that this is a write when asserted, and a read when not                                  |
| wb_stb_i  |          1 | Indicates that this there is a request for this slave when asserted                                |
| wb_dat_o  |         32 | 32-bit data output from the core                                                                   |
| wb_ack_o  |          1 | Indicates the termination of a bus cycle                                                           |
| dds_clk_i |          1 | Input to the DDS  core itself. This clock provides $f_{dds}$ defined in the equation in Operations |
| wave_o    |         16 | Word to be passed to ADC to generate your output waveform                                          |
TODO Update wb addr width
-----
* Design
** Design Overview
The design will be done in Verilog. All utilized features need to be synthesizable via Xilinx's Synthesizer. The design shall follow the Open Core's Coding guidelines(with postfix rather than prefix variable labels).

All modules should be parameterizable where possible.

Verilator's linter will be used throughout the design project. Every module must past linting with no warnings or have a waiver.

Git will be used for version control.
*** Lint Warning Wavers
-----
* Verification
** Verification Plan
The verification of the core will follow the methods and test points listed below.
*** Verification Methodology
Verification will be performed in standard verilog via Icarus Verilog. Make will be used to organize test runs.

*** Functional Coverage
**** Bit Bash
All DUT registers and read permissions will be ensured via a bit bash sequence on the Register Map.
**** Wave Outputs
The DUT will be tested for all possible waveform outputs {SINE, SAWTOOTH, RANDOM, RAM_BASED}. (The RAM_BASED wave will test a user defined wave of each the following types{SINE, TRIANGLE, PULSE})
**** Tuning Word
The DUT will vary the output frequency based upon tuning word.
**** Gain Testing
The DUT will vary the output gain based on gain word.
**** Offset testing
The DUT vary the output offset based on offset word.
** TODO Verification Results
-----
All tests by results randomize completely. The following cases are some cherry picked corner cases that the default random case had temporarily overwritten for the sake of recording these results.

Note: Initially the offset was reset to the wrong value of 0x0fff rather than 0x7fff. You'll notice that the pictures prior to offset testing will use that default. This was fixed for the final release.
*** Bit Bash
Passing
*** Wave Outputs
All values besides dds_src are set to the defaults. Note that this tests the defaults for the other test conditions as well
**** Sine Wave
#+caption: Sine Wave
[[file:wave_sin.png]]
**** Sawtooth Wave
#+caption: Sawtooth Wave
[[file:wave_saw.png]]
**** Triangle Wave
#+caption: Triangle Wave
[[file:wave_tri.png]]
**** Random Wave
#+caption: Random Wave
[[file:wave_rand.png]]
*** Tuning Word
All values besides tuning_word are set to the defaults.
**** 8'h0F 
#+caption: Tuning Word of 8'h0F
[[file:tune_0f.png]]
**** 8'h3F 
#+caption: Tuning Word of 8'h3F
[[file:tune_3f.png]]
**** 8'hFF 
#+caption: Tuning Word of 8'hFF
[[file:tune_ff.png]]
*** Gain Testing
All values besides gain_word are set to the default.
**** x2
#+caption: Gain x2
[[file:gain_2.png]]
**** x4
#+caption: Gain x4
[[file:gain_4.png]]
**** x8
#+caption: Gain x8
[[file:gain_8.png]]
*** Offset Testing
All values besides offset word are set to the default
**** 16'd0
#+caption: Offset 16'h0000
[[file:offset_0.png]]
**** 16'H3FFF
#+caption: Offset 16'h3FFF
[[file:offset_3fff.png]]
**** 16'hFFFF
#+caption: Offset 16'hFFFF
[[file:offset_ffff.png]]
*** Final Results
From the results above you can see full functional verification of the DUT. All features are working according to the specification.
* Revision History
 
#+caption: Change history for this core
| Rev |       Date | Author | Description                    |
| 1.0 | 2022-12-04 | phoey  | Release of Core                |
| 0.2 | 28-11-2022 | phoey  | update register map and memory |
| 0.1 | 30-10-2022 | phoey  | initial release                |
-----
* Appendices
** Resources & References
*** ADI - All About Direct Digital Synthesis
https://www.analog.com/en/analog-dialogue/articles/all-about-direct-digital-synthesis.html
*** Open Cores Specification Template
https://cdn.opencores.org/downloads/specification_template.dot
*** Open Cores Coding Guideline
https://opencores.org/websvn/filedetails?repname=common&path=%2Fcommon%2Ftrunk%2Fopencores_coding_guidelines.pdf
*** Open Cores Wishbone B4 Specification
https://cdn.opencores.org/downloads/wbspec_b4.pdf
*** ZipCPU - Wishbone Slave Guide
https://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html
*** Sin Table Generation and Guide
https://projectf.io/posts/fpga-sine-table/
*** LFSR Guide
https://simplefpga.blogspot.com/2013/02/random-number-generator-in-verilog-fpga.html
*** Generate LUTs
https://github.com/ShenghanGao/Lookup-Table
* Code

