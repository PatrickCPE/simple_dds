#+title: Simple DDS Specification
#+author: Patrick Hoey
#+email: patrickrhoey@gmail.com
#+date: 2022-11-28
#+description: A small DDS core capable of generating sin or arbitrary waves based upon configuration.

#+OPTIONS: ^:nil

-----
* Overview
Simple DDS Specification

Author: Patrick Hoey

Email: patrickrhoey@gmail.com

Date: 2022-10-30

Revision: 0.1

Description:
DDS (Direct Digital Synthesis) core capable of waveform generation. The core has a Wishbone B4 Classic bus interface.
-----
* Architecture
#+caption: Simple DDS Block Diagram
[[file:simple_dds.png]]
-----
* Operation
A Direct Digital Synthesizer (DDS) is a method of generating a variable frequency waveform via a digital method. It operates via a tuning word, an input clock, a phase accumulator, and a look up table(LUT).

The DDS core has a pointer(the phase accumulator) that will reference a location in one of the LUTs. This LUT contains the data for a waveform (for example the values of Sine).
Your tuning word is a measure of how many addresses to increment every time your DDS clock edge occurs(overflow returns you to the start of the LUT).
Therefore your DDS will iterate through the LUT faster with a higher valued tuning word based, at the cost of hitting less values.

#+caption: Phase accumulator diagram
[[file:phase_acccumulator.png]]

Therein is your trade-off with a DDS. You can iterate through the waveform shape slowly with very high precision and a slow output frequency, or iterate through it quickly with less precision and a high output frequency. 

| variable       | description                                                      |
| $f_{out}$      | output frequency of your signal                                  |
| M              | Tuning word value (Magnitude of jumps on your phase accumulator) |
| $f_{dds\_clk}$ | Frequency of your input clock to the DDS core                    |
| n              | Width of your phase accumulator                                  |

$f_{out} = {{M * f_{dds\_clk}} / 2^n}$

This particular core has 4 LUTs you can iterate through. A sine wave, a sawtooth wave, a random wave(which isn't truly a LUT), and a user defined wave that you can program into RAM via the interface. \
There is also a gain and offset register that the user can program to modify the output signal. The output signal pipes directly into a DAC to create your waveform.

This core communicates with external IP via a Wishbone B4 Classic Bus. See references to access the specification.

#+caption: Reset Sequence
[[file:reset_seq.png]]
Reset must be asserted for at least one clock cycle. It may be asserted any length of clock cycles.

#+caption: Read Sequence
[[file:read_seq.png]]
wb_stb_i, wb_we_i, and wb_addr_i must be ready before the rising edge of wb_clk_i.
wb_dat_o and wb_ack will become valid some time before the next bclk edge and will remain valid for one clock.


#+caption: Write Sequence
[[file:write_seq.png]]
This is effectively the same as a read except wb_we_i is driven high.
wb_ack_o will be driven high on the next cycle if the write was successful.
-----
* Registers and Memory
** Registers
| register name | register address | Bit Map                                | R/W | Description                                                                          | Initial Value |
| ready         |            0x000 | {[31:1] reserved, [0] ready}           | R   | Will assert high once core can begin operation following a reset                     |    0x00000000 |
| enable        |            0x001 | {[31:1] reserved, [0] enable}          | R/W | Enables DDS operation once written. Ready must be high before you can write to this  |    0x00000000 |
| dds_src       |            0x002 | {[31:2] reserved, [1:0] dds_src}       | R/W | Indicates the source of the dds signal. 0=Sine, 1=Sawtooth, 2 = Triangle, 3=Random   |    0x00000000 |
| tuning_word   |            0x003 | {[31:8] reserved, [7:0] tuning_word}   | R/W | Tuning word for the DDS phase accumulator                                            |    0x00000001 |
| gain_word     |            0x004 | {[31:2] reserved, [1:0] gain_word}     | R/W | Multiplier for gain. Gain is a multiple of 2 so setting gain_word = 0x3 -> 2^3 -> x8 |    0x00000000 |
| offset_word   |            0x005 | {31:16} reserved, [15:0] offset_word   | R/W | Offset to be added to the result.                                                    |    0x00007FFF |
# TODO add seed register and determine seed width

-----
** LUTs
| LUT      | LUT Width | LUT Data Width | Data Width | Description                                 |
| Sine     |       256 |              8 |          8 | Sine look up table used by the DDS core     |
| Sawtooth |       256 |              8 |          8 | Sawtooth look up table used by the DDS core |
| Triangle |       256 |              8 |          8 | Triangle look up table used by the DDS core |
-----
* Clocks
The following clocks are present within the design.
| clock name | clock description                                                               | Clock max frequency |
| wb_clk_i   | Wishbone B4 Classic bus clock input                                             | Process Dependent   |
| dds_clk_i  | Input to the DDS core itself. The frequency at which the phase acumulator jumps | Process Dependent   |

Clock speeds will depend upon the specific cell library or FPGA this design processes. All resets within the design are synchronous.
-----
* IO Ports
Wishbone interface uses the Wishbone B4 Classic slave interface. The optional features select, error, and retry are not supported on the bus. Due to the exclusion of the select line, all data transfers are 32-bit wide.
| port name | port width | description                                                                                        |
| wb_clk_i  |          1 | Input clock to the core                                                                            |
| wb_rst_i  |          1 | Reset for the core                                                                                 |
| wb_dat_i  |         32 | 32-bit data input to the core                                                                      |
| wb_addr_i |         12 | Indicates a valid bus cycle is in progress. Remains asserted for multi clock bus transactions      |
| wb_we_i   |          1 | Indicates that this is a write when asserted, and a read when not                                  |
| wb_stb_i  |          1 | Indicates that this there is a request for this slave when asserted                                |
| wb_dat_o  |         32 | 32-bit data output from the core                                                                   |
| wb_ack_o  |          1 | Indicates the termination of a bus cycle                                                           |
| dds_clk_i |          1 | Input to the DDS  core itself. This clock provides $f_{dds}$ defined in the equation in Operations |
| wave_o    |         16 | Word to be passed to ADC to generate your output waveform                                          |
-----
* Design
** Design Overview
The design will be done in Verilog. All utilized features need to be synthesizable via Xilinx's Synthesizer. The design shall follow the Open Core's Coding guidelines.

All modules should be parameterizable where possible.

Verilator's linter will be used throughout the design project. Every module must past linting with no warnings or have a waiver.

Git will be used for version control.
*** Lint Warning Wavers
| Warning                 | Reason for Waiver                                                                                                   |
| Unused Bits in Register | The control and status registers were purposely made to large at 32 bit. Only the actually mapped bit fields matter |
-----
* Verification
** Verification Plan
The verification of the core will follow the methods and test points listed below.
*** Verification Methodology
Verification will be performed in standard verilog via Icarus Verilog. Make will be used to organize test runs.
*** Functional Coverage
**** Bit Bash
All DUT registers and read permissions will be ensured via a bit bash sequence on the Register Map.
**** Wave Outputs
The DUT will be tested for all possible waveform outputs {SINE, SAWTOOTH, RANDOM, RAM_BASED}. (The RAM_BASED wave will test a user defined wave of each the following types{SINE, TRIANGLE, PULSE})
**** Tuning Word
The DUT will vary the output frequency based upon tuning word.
**** Gain Testing
The DUT will vary the output gain based on gain word.
**** Offset testing
The DUT will vary the output offset based on offset word.
** Verification Results
-----
*** Simple_DDS Example Waveforms
The following waveform is of the randomized test case for the core.

#+caption: Test Case Waveforms Screenshot
[[file:wave_screenshot.png]]
Step 1. Register testing
Step 2. Write test condition to core
Step 3. Let dds core run

Following this a python script parses the output log and plots the wave.
*** Simple DDS Log Results
See the abbreviated results from the testbench here

simple_dds_log_20221204211523.tb
#+begin_src shell
  VCD info: dumpfile ../out/wave_simple_dds.vcd opened for output.
  INFO: Testing Register Writes
  ---------------------------------------------------------------------------
  INFO: DDS_SRC: SINE
  INFO: TUNING_WORD 0x01
  INFO GAIN_WORD: x1
  INFO: OFFSET_WORD 0x7fff
  ---------------------------------------------------------------------------
  # Register Reset Testing
  INFO: WB read from 0x0000
  INFO: WB read 0x00000001 from 0x0000
  INFO: WB read from 0x0001
  INFO: WB read 0x00000000 from 0x0001
  ...
  # Register Write/Read Testing
  INFO: WB Writing 0xffffffff to 0x0000
  INFO: WB Wrote 0xffffffff to 0x0000
  INFO: WB Writing 0xffffffff to 0x0001
  ...
  INFO: WB read from 0x0001
  INFO: WB read 0xffffffff from 0x0001
  INFO: WB read from 0x0002
  ...
  # Configure Test Conditions
  INFO: WB Writing 0x00000000 to 0x0002
  INFO: WB Wrote 0x00000000 to 0x0002
  INFO: WB Writing 0x00000001 to 0x0003
  INFO: WB Wrote 0x00000001 to 0x0003
  INFO: WB Writing 0x00000000 to 0x0004
  INFO: WB Wrote 0x00000000 to 0x0004
  INFO: WB Writing 0x00007fff to 0x0005
  INFO: WB Wrote 0x00007fff to 0x0005
  INFO: WB Writing 0x00000001 to 0x0001
  INFO: WB Wrote 0x00000001 to 0x0001
  # Sample DDS Output
  INFO: sample:          0 value:33022
  INFO: sample:          1 value:33022
  INFO: sample:          2 value:33022
  INFO: sample:          3 value:33022
  ...
  INFO: sample:        498 value:32992
  INFO: sample:        499 value:32990
  INFO: Test Complete
  /home/patrick/ws/school/verilog_and_vhdl/simple_dds/sim/rtl_sim/src/simple_dds_tb.v:121: $finish called at 13245 (1s)
#+end_src
*** DDS testing Results Results
All tests by results randomize completely. The following cases are some cherry picked corner cases that the default random case had temporarily overwritten for the sake of recording these results.

Note: Initially the offset was reset to the wrong value of 0x0fff rather than 0x7fff. You'll notice that the pictures prior to offset testing will use that default. This was fixed for the final release.
**** Bit Bash
Passing
**** Wave Outputs
All values besides dds_src are set to the defaults. Note that this tests the defaults for the other test conditions as well
***** Sine Wave
#+caption: Sine Wave
[[file:wave_sin.png]]
***** Sawtooth Wave
#+caption: Sawtooth Wave
[[file:wave_saw.png]]
***** Triangle Wave
#+caption: Triangle Wave
[[file:wave_tri.png]]
***** Random Wave
#+caption: Random Wave
[[file:wave_rand.png]]
**** Tuning Word
All values besides tuning_word are set to the defaults.
***** 8'h0F 
#+caption: Tuning Word of 8'h0F
[[file:tune_0f.png]]
***** 8'h3F 
#+caption: Tuning Word of 8'h3F
[[file:tune_3f.png]]
***** 8'hFF 
#+caption: Tuning Word of 8'hFF
[[file:tune_ff.png]]
**** Gain Testing
All values besides gain_word are set to the default.
***** x2
#+caption: Gain x2
[[file:gain_2.png]]
***** x4
#+caption: Gain x4
[[file:gain_4.png]]
***** x8
#+caption: Gain x8
[[file:gain_8.png]]
**** Offset Testing
All values besides offset word are set to the default
***** 16'd0
#+caption: Offset 16'h0000
[[file:offset_0.png]]
***** 16'H3FFF
#+caption: Offset 16'h3FFF
[[file:offset_3fff.png]]
***** 16'hFFFF
Note that this is what happens when your waveform clips completely :)
#+caption: Offset 16'hFFFF
[[file:offset_ffff.png]]
*** Final Results
From the results above you can see full functional verification of the DUT. All features are working according to the specification.
* Revision History
 
#+caption: Change history for this core
| Rev |       Date | Author | Description                    |
| 1.0 | 2022-12-04 | phoey  | Release of Core                |
| 0.2 | 28-11-2022 | phoey  | update register map and memory |
| 0.1 | 30-10-2022 | phoey  | initial release                |
-----
* Appendices
** Resources & References
*** ADI - All About Direct Digital Synthesis
https://www.analog.com/en/analog-dialogue/articles/all-about-direct-digital-synthesis.html
*** Open Cores Specification Template
https://cdn.opencores.org/downloads/specification_template.dot
*** Open Cores Coding Guideline
https://opencores.org/websvn/filedetails?repname=common&path=%2Fcommon%2Ftrunk%2Fopencores_coding_guidelines.pdf
*** Open Cores Wishbone B4 Specification
https://cdn.opencores.org/downloads/wbspec_b4.pdf
*** ZipCPU - Wishbone Slave Guide
https://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html
*** Sin Table Generation and Guide
https://projectf.io/posts/fpga-sine-table/
*** LFSR Guide
https://simplefpga.blogspot.com/2013/02/random-number-generator-in-verilog-fpga.html
*** Generate LUTs
https://github.com/ShenghanGao/Lookup-Table
* Code
** RTL
simple_dds.v
#+begin_src verilog
  //                              -*- Mode: Verilog -*-
  // Filename        : simple_dds.v
  // Description     : A direct digital synthesis core capable of sine, sawtooth, random, and user defined waves
  // Author          : Patrick Hoey
  // Created On      : Sun Nov 27 18:23:16 2022
  // Last Modified By: Patrick Hoey
  // Last Modified On: Sun Nov 27 18:23:16 2022
  // Update Count    : 0
  // Status          : Unknown, Use with caution!

  module simple_dds (/*AUTOARG*/
                     // Outputs
                     wb_dat_o, wb_ack_o, wave_o,
                     // Inputs
                     wb_clk_i, wb_rst_i, wb_dat_i, wb_addr_i, wb_we_i, wb_stb_i, dds_clk_i
                     ) ;
     //------------------------------------------------------------------------------------------------------------------------
     // Parameters
     //------------------------------------------------------------------------------------------------------------------------
     parameter DATA_WIDTH = 32;
     parameter ADDR_WIDTH = 16;
     parameter WAVE_WIDTH = 16;

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // I/O
     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Wishbone Interface Signals
     input wire wb_clk_i;
     input wire wb_rst_i;
     input wire [DATA_WIDTH-1:0] wb_dat_i;
     input wire [ADDR_WIDTH-1:0] wb_addr_i;
     input wire                  wb_we_i;
     input wire                  wb_stb_i;

     output wire [DATA_WIDTH-1:0] wb_dat_o;
     output wire                  wb_ack_o;

     // Misc IO signals
     input wire                   dds_clk_i;

     output wire [WAVE_WIDTH-1:0] wave_o;

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Internal Signals
     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Register Map Signals
     reg [DATA_WIDTH-1:0]         reg_map_r [5:0]; // Consult Spec for register map

     // Observation wires to ensure registers work properly
     /* verilator lint_off UNUSED */
     wire [DATA_WIDTH-1:0]        ready_w;
     wire [DATA_WIDTH-1:0]        enable_w;
     wire [DATA_WIDTH-1:0]        dds_src_w;
     wire [DATA_WIDTH-1:0]        tuning_word_w;
     wire [DATA_WIDTH-1:0]        gain_word_w;
     wire [DATA_WIDTH-1:0]        offset_word_w;
     /* verilator lint_on UNUSED */

     // Registered output signals
     reg [DATA_WIDTH-1:0]         wb_dat_r;
     reg                          wb_ack_r;
     wire [WAVE_WIDTH-1:0]        wave_res;


     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Module Instantiations
     //--------------------------------------------------------------------------------------------------------------------------------------------
     dds_core dds_0(// Outputs
                    .wave_o               (wave_res),
                    // Inputs
                    .dds_clk_i            (dds_clk_i),
                    .wb_clk_i             (wb_clk_i),
                    .wb_rst_i             (wb_rst_i),
                    .dds_src_i            (dds_src_w[1:0]),
                    .tuning_word_i        (tuning_word_w[7:0]),
                    .gain_word_i          (gain_word_w[1:0]),
                    .offset_word_i        (offset_word_w[15:0]));


     //--------------------------------------------------------------------------------------------------------------------------------------------
     // RTL
     //--------------------------------------------------------------------------------------------------------------------------------------------
     always @ (posedge wb_clk_i) begin
        if(wb_rst_i) begin
           wb_ack_r      <= 1'b0;
           reg_map_r[0]  <= 1;
           reg_map_r[1]  <= 0;
           reg_map_r[2]  <= 0;
           reg_map_r[3]  <= 1;
           reg_map_r[4]  <= 0;
           reg_map_r[5]  <= 32'h0000_7FFF;
        end else begin
           // Writes------------------------
           if((wb_stb_i) && (wb_we_i)) begin
              if((wb_addr_i > 16'h0000) && (wb_addr_i < 16'h0006)) begin
                 reg_map_r[wb_addr_i[2:0]] <= wb_dat_i;
              end
           end

           // Reads-------------------------
           else if((wb_stb_i) && (~wb_we_i)) begin
              if(wb_addr_i < 16'h0006) begin
                 wb_dat_r <= reg_map_r[wb_addr_i[2:0]];
              end
           end

           // Acknowledge transaction------
           wb_ack_r <= wb_stb_i;
        end
     end

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Assigns
     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Wishbone
     assign wb_dat_o = wb_dat_r;
     assign wb_ack_o = wb_ack_r;

     // Waveform
     assign wave_o = enable_w[0] ? wave_res : 0;

     // Register Observation Wires
     assign ready_w = reg_map_r[0];
     assign enable_w = reg_map_r[1];
     assign dds_src_w = reg_map_r[2];
     assign tuning_word_w = reg_map_r[3];
     assign gain_word_w = reg_map_r[4];
     assign offset_word_w = reg_map_r[5];

  endmodule // simple_dds
#+end_src

dds_core.v
#+begin_src verilog
  //                              -*- Mode: Verilog -*-
  // Filename        : dds_core.v
  // Description     : Generates the DDS output signal. Note that 3 dds clock edges must occur before the signal becomes valid
  // Author          : Patrick
  // Created On      : Sun Dec  4 17:59:32 2022
  // Last Modified By: Patrick
  // Last Modified On: Sun Dec  4 17:59:32 2022
  // Update Count    : 0
  // Status          : Unknown, Use with caution!


  module dds_core (/*AUTOARG*/
                   // Outputs
                   wave_o,
                   // Inputs
                   dds_clk_i, wb_clk_i, wb_rst_i, dds_src_i, tuning_word_i, gain_word_i,
                   offset_word_i
                   ) ;
     //------------------------------------------------------------------------------------------------------------------------
     // Parameters
     //------------------------------------------------------------------------------------------------------------------------
     parameter WAVE_WIDTH = 16;

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // I/O
     //--------------------------------------------------------------------------------------------------------------------------------------------
     input wire dds_clk_i;
     input wire wb_clk_i;
     input wire wb_rst_i;
     input wire [1:0] dds_src_i;
     input wire [7:0] tuning_word_i;
     input wire [1:0] gain_word_i;
     input wire [15:0] offset_word_i;

     output wire [WAVE_WIDTH-1:0] wave_o;

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Internal Signals
     //--------------------------------------------------------------------------------------------------------------------------------------------
     reg [7:0]                    phase_acum_r;
     wire [7:0]                   sine_w;
     wire [7:0]                   tri_w;
     wire [7:0]                   saw_w;
     wire [7:0]                   rand_w;

     reg [WAVE_WIDTH/2-1:0]       wave_pre_multiply;
     reg [WAVE_WIDTH-1:0]         wave_pre_offset;
     reg [WAVE_WIDTH-1:0]         wave_r;

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Module Instantiations
     //--------------------------------------------------------------------------------------------------------------------------------------------
     sine_lut sine_0(/// Outputs
                     .sine_o              (sine_w),
                     // Inputs
                     .address_i           (phase_acum_r));
     tri_lut tri_0(// Outputs
                   .tri_o                 (tri_w),
                   // Inputs
                   .address_i             (phase_acum_r));
     saw_lut saw_0(// Outputs
                   .saw_o                 (saw_w),
                   // Inputs
                   .address_i             (phase_acum_r));

     lfsr lfsr_0(// Outputs
                 .rand_o                  (rand_w),
                 // Inputs
                 .clk_i                   (dds_clk_i),
                 .rst_i                   (wb_rst_i));

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // RTL
     //--------------------------------------------------------------------------------------------------------------------------------------------
     always @ (posedge dds_clk_i or posedge wb_clk_i) begin
        if (wb_clk_i & wb_rst_i) begin
           phase_acum_r <= 8'd0;
           wave_pre_multiply <= 0;
           wave_pre_offset <= 0;
           wave_r <= 0;
        end else begin
           phase_acum_r <= phase_acum_r + tuning_word_i;
           case (dds_src_i)
              2'b00 : wave_pre_multiply <= sine_w; // Sine
              2'b01 : wave_pre_multiply <= saw_w; // Sawtooth
              2'b10 : wave_pre_multiply <= tri_w; // Triangle
              2'b11 : wave_pre_multiply <= rand_w; // Random
           endcase // case (dds_src_i)
           case (gain_word_i)
              2'b00 : wave_pre_offset <= {8'b0, wave_pre_multiply}; // x1
              2'b01 : wave_pre_offset <= {7'b0, wave_pre_multiply, 1'b0}; // x2
              2'b10 : wave_pre_offset <= {6'b0, wave_pre_multiply, 2'b0}; // x4
              2'b11 : wave_pre_offset <= {5'b0, wave_pre_multiply, 3'b0}; // x8
           endcase // case (gain_word_i)
           wave_r <= wave_pre_offset + offset_word_i;
        end
     end

     //--------------------------------------------------------------------------------------------------------------------------------------------
     // Assigns
     //--------------------------------------------------------------------------------------------------------------------------------------------
     assign wave_o = wave_r;

  endmodule // dds_core
#+end_src

lfsr.v
#+begin_src verilog
  //                              -*- Mode: Verilog -*-
  // Filename        : lfsr.v
  // Description     : LFSR Random Number Generator
  // Author          : Patrick
  // Created On      : Sun Dec  4 18:12:53 2022
  // Last Modified By: Patrick
  // Last Modified On: Sun Dec  4 18:12:53 2022
  // Update Count    : 0
  // Status          : Unknown, Use with caution!
  // Based on https://simplefpga.blogspot.com/2013/02/random-number-generator-in-verilog-fpga.html


  module lfsr (/*AUTOARG*/
               // Outputs
               rand_o,
               // Inputs
               clk_i, rst_i
               ) ;
     input wire clk_i;
     input wire rst_i;
     output wire [7:0] rand_o;

     wire              feedback_w;

     reg [7:0]         rand_r;

     always @ (posedge clk_i) begin
        if (rst_i) begin
           rand_r <= 8'hFF;
        end else begin
           rand_r <= {rand_r[6:0], feedback_w};
        end
     end

     assign feedback_w = rand_r[7] ^ rand_r[5]  ^ rand_r[4]  ^ rand_r[3];
     assign rand_o = rand_r;
  endmodule // lfsr
#+end_src

sin_lut.v
#+begin_src verilog
  module sine_lut (/*AUTOARG*/
                   // Outputs
                   sine_o,
                   // Inputs
                   address_i
                   ) ;
     input wire [7:0] address_i;
     output reg [7:0] sine_o;

     always @ (*) begin
        case (address_i)
           8'b00000000: sine_o = 8'b10000000;
           8'b00000001: sine_o = 8'b10000011;
           8'b00000010: sine_o = 8'b10000110;
           //Cut for the sake of printing...
           8'b11111111: sine_o = 8'b01111101;
        endcase
     end
  endmodule // sine_lut
#+end_src

saw_lut.v
#+begin_src verilog
  module saw_lut (/*AUTOARG*/
                  // Outputs
                  saw_o,
                  // Inputs
                  address_i
                  ) ;
     input wire [7:0] address_i;
     output reg [7:0] saw_o;

     always @ (*) begin
        case(address_i)
           8'b00000000: saw_o = 8'b00000000;
           8'b00000001: saw_o = 8'b00000001;
           8'b00000010: saw_o = 8'b00000010;
           //Cut for the sake of printing...
           8'b11111111: saw_o = 8'b11111111;
        endcase // case (address_i)
     end
  endmodule // saw_lut
#+end_src

tri_lut.v
#+begin_src verilog
  module tri_lut (/*AUTOARG*/
                  // Outputs
                  tri_o,
                  // Inputs
                  address_i
                  ) ;
     input wire [7:0] address_i;
     output reg [7:0] tri_o;

     always @ (*) begin
        case(address_i)
           8'b00000000: tri_o = 8'b10000000;
           8'b00000001: tri_o = 8'b10000010;
           8'b00000010: tri_o = 8'b10000100;
           8'b00000011: tri_o = 8'b10000110;
           8'b00000100: tri_o = 8'b10001000;
           //Cut for the sake of printing...
           8'b11111111: tri_o = 8'b01111110;
        endcase // case (address_i)
     end
  endmodule // tri_lut
#+end_src
** TB
lfsr_tb.v
#+begin_src verilog
  module lfsr_tb (/*AUTOARG*/) ;
     parameter TRACE = 1;

     reg clk_i_tb;
     reg rst_i_tb;
     wire [7:0] rand_o_tb;


     lfsr lfsr0(/*AUTOINST*/
                // Outputs
                .rand_o                   (rand_o_tb),
                // Inputs
                .clk_i                    (clk_i_tb),
                .rst_i                    (rst_i_tb));

     initial begin
        clk_i_tb     = 0;
        rst_i_tb     = 0;
        #10 rst_i_tb = 1;
        #10 rst_i_tb = 0;
        #10000 $finish;
     end

     initial begin
        forever begin
           #10 clk_i_tb = ~clk_i_tb;
        end
     end


     always @ (posedge clk_i_tb) $display("Current Value of Random Out:%d %h", rand_o_tb, rand_o_tb);

     if (TRACE == 1) initial begin
        $dumpfile("../out/wave_lfsr.vcd");
        $dumpvars;
     end

  endmodule // lfsr_tb
#+end_src

simple_dds_tb.v
#+begin_src verilog
  module simple_dds_tb ();
     parameter SEED = 100;
     integer seed = SEED;
     parameter TRACE = 1;
     parameter TIMEOUT = 50000;
     parameter WB_CLOCK_PERIOD = 100;
     parameter WB_CLOCK_HALF_PERIOD = WB_CLOCK_PERIOD / 2;
     parameter DDS_CLOCK_PERIOD = 10;
     parameter DDS_CLOCK_HALF_PERIOD = DDS_CLOCK_PERIOD / 2;

     parameter DATA_WIDTH = 32;
     parameter ADDR_WIDTH = 16;
     parameter WAVE_WIDTH = 16;

     // Register Address Definitions
     parameter READY = 32'd0,
        ENABLE      = 32'd1,
        DDS_SRC     = 32'd2,
        TUNING_WORD = 32'd3,
        GAIN_WORD   = 32'd4,
        OFFSET_WORD = 32'd5;

     // Register Reset Values
     parameter READY_RST_VAL = 32'd0,
        ENABLE_RST_VAL = 32'd0,
        DDS_SRC_RST_VAL = 32'd0,
        TUNING_WORD_RST_VAL = 32'd1,
        GAIN_WORD_RST_VAL = 32'd0,
        OFFSET_WORD_RST_VAL = 32'h000000FF;


     reg     wb_clk_i_tb;
     reg     wb_rst_i_tb;
     reg [DATA_WIDTH-1:0] wb_dat_i_tb;
     reg [ADDR_WIDTH-1:0] wb_addr_i_tb;
     reg                  wb_we_i_tb;
     reg                  wb_stb_i_tb;

     wire [DATA_WIDTH-1:0] wb_dat_o_tb;
     wire                  wb_ack_o_tb;

     // Misc IO signals
     reg                   dds_clk_i_tb;

     wire [WAVE_WIDTH-1:0] wave_o_tb;


     simple_dds #(.DATA_WIDTH(DATA_WIDTH), .ADDR_WIDTH(ADDR_WIDTH), .WAVE_WIDTH(WAVE_WIDTH))
     dut0(
          // Outputs
          .wb_dat_o            (wb_dat_o_tb),
          .wb_ack_o            (wb_ack_o_tb),
          .wave_o              (wave_o_tb),
          // Inputs
          .wb_clk_i            (wb_clk_i_tb),
          .wb_rst_i            (wb_rst_i_tb),
          .wb_dat_i            (wb_dat_i_tb),
          .wb_addr_i           (wb_addr_i_tb),
          .wb_we_i             (wb_we_i_tb),
          .wb_stb_i            (wb_stb_i_tb),
          .dds_clk_i           (dds_clk_i_tb)
          );

     // Wave Dump
     if (TRACE == 1) initial begin
        $dumpfile("../out/wave_simple_dds.vcd");
        $dumpvars;
     end

     // Watchdog Timeout
     initial begin
        #TIMEOUT $finish;
     end

     // DDS Clock Generator
     initial begin
        forever #DDS_CLOCK_HALF_PERIOD dds_clk_i_tb = ~dds_clk_i_tb;
     end

     //// WB Clock Generator
     initial begin
        forever #WB_CLOCK_HALF_PERIOD wb_clk_i_tb = ~wb_clk_i_tb;
     end

     reg [DATA_WIDTH-1:0] read_data;
     reg [ADDR_WIDTH-1:0] read_addr;

     // DUT Random Register Values
     reg                  enable_tb;
     reg [1:0]            dds_src_tb;
     reg [7:0]            tuning_word_tb;
     reg [1:0]            gain_word_tb;
     reg [15:0]           offset_word_tb;

     integer              sample_cntr;
     initial begin
        $display("INFO: Testing Register Writes");
        // Initial Values for Registers-----------------
        wb_clk_i_tb  = 0;
        wb_rst_i_tb  = 0;
        wb_dat_i_tb  = 0;
        wb_addr_i_tb = 0;
        wb_we_i_tb   = 0;
        wb_stb_i_tb  = 0;
        dds_clk_i_tb = 0;

        read_data    = 0;
        read_addr    = 0;

        // Reset DUT------------------------------------
        @ (negedge wb_clk_i_tb);
        wb_rst_i_tb = 1;
        repeat (5) @ (posedge wb_clk_i_tb);
        wb_rst_i_tb = 0;
        @ (posedge wb_clk_i_tb);
        // Test Register R/W----------------------------
        randomize_test();
        run_reg_test();
        run_wave_test();
        #1000 $display("INFO: Test Complete");
        $finish;
     end // initial begin



     task wb_write(input [ADDR_WIDTH-1:0] addr, input [DATA_WIDTH-1:0] data);
        begin
           $display("INFO: WB Writing 0x%h to 0x%h", data, addr);

           @ (negedge wb_clk_i_tb); // Sync to non sample edge
           wb_we_i_tb   = 1;
           wb_addr_i_tb = addr;
           wb_dat_i_tb  = data;
           wb_stb_i_tb = 1;
           @ (posedge wb_clk_i_tb); // Write to the DUT
           @ (posedge wb_clk_i_tb); // Get an ACK next cycle
           if (wb_ack_o_tb) $display("INFO: WB Wrote 0x%h to 0x%h", data, addr);
           else $display("ERROR: WB Write %h to 0x%h failed. No ACK", data, addr); wb_stb_i_tb = 0; // TR over
        end
     endtask // wb_write

     task wb_read(input [ADDR_WIDTH-1:0] addr, output [DATA_WIDTH-1:0] data);
        begin
           $display("INFO: WB read from 0x%h", addr);

           @ (negedge wb_clk_i_tb); // Sync to non sample edge
           wb_we_i_tb   = 0;
           wb_addr_i_tb = addr;
           wb_stb_i_tb = 1;
           @ (posedge wb_clk_i_tb); // Write to the DUT
           @ (posedge wb_clk_i_tb); // Get an ACK next cycle and read data
           data = wb_dat_o_tb;
           if (wb_ack_o_tb) $display("INFO: WB read 0x%h from 0x%h", data, addr);
           else $display("ERROR: WB Read from 0x%h failed. No ACK", addr);
           wb_stb_i_tb = 0; // TR over
        end
     endtask // wb_read

     task run_reg_test();
        begin

           // Ensure DUT Reset Complete and DUT is ready
           while(read_data !== 32'd1) begin
              wb_read(READY, read_data);
           end

           // Read and assert proper reset values
           wb_read(ENABLE, read_data);
           if(!(read_data === ENABLE_RST_VAL)) $display("ERROR: ENABLE reset to wrong value: 0x%h", read_data);
           wb_read(DDS_SRC, read_data);
           if(!(read_data === DDS_SRC_RST_VAL)) $display("ERROR: DDS_SRC reset to wrong value: 0x%h", read_data);
           wb_read(TUNING_WORD, read_data);
           if(!(read_data === TUNING_WORD_RST_VAL)) $display("ERROR: TUNING_WORD reset to wrong value: 0x%h", read_data);
           wb_read(GAIN_WORD, read_data);
           if(!(read_data === GAIN_WORD_RST_VAL)) $display("ERROR: GAIN_WORD reset to wrong value: 0x%h", read_data);
           wb_read(OFFSET_WORD, read_data);
           if(!(read_data === OFFSET_WORD_RST_VAL)) $display("ERROR: OFFSET_WORD reset to wrong value: 0x%h", read_data);

           // Set
           wb_write(READY, 32'hffff_ffff);
           wb_write(ENABLE, 32'hffff_ffff);
           wb_write(DDS_SRC, 32'hffff_ffff);
           wb_write(TUNING_WORD, 32'hffff_ffff);
           wb_write(GAIN_WORD, 32'hffff_ffff);
           wb_write(OFFSET_WORD, 32'hffff_ffff);

           // Read and assert proper bit fields were set
           wb_read(ENABLE, read_data);
           if(!(read_data[0] === 1'b1)) $display("ERROR: ENABLE reset to wrong value: 0x%h", read_data);
           wb_read(DDS_SRC, read_data);
           if(!(read_data[1:0] === 2'b11)) $display("ERROR: DDS_SRC reset to wrong value: 0x%h", read_data);
           wb_read(TUNING_WORD, read_data);
           if(!(read_data[7:0] === 8'hff)) $display("ERROR: TUNING_WORD reset to wrong value: 0x%h", read_data);
           wb_read(GAIN_WORD, read_data);
           if(!(read_data[1:0] === 2'b11)) $display("ERROR: GAIN_WORD reset to wrong value: 0x%h", read_data);
           wb_read(OFFSET_WORD, read_data);
           if(!(read_data[15:0] === 16'hffff)) $display("ERROR: OFFSET_WORD reset to wrong value: 0x%h", read_data);

           // Clear
           wb_write(READY, 32'd0);
           wb_write(ENABLE, 32'd0);
           wb_write(DDS_SRC, 32'd0);
           wb_write(TUNING_WORD, 32'd0);
           wb_write(GAIN_WORD, 32'd0);
           wb_write(OFFSET_WORD, 32'd0);

           // Read and assert proper bit fields were cleared
           wb_read(ENABLE, read_data);
           if(!(read_data[0] === 1'b0)) $display("ERROR: ENABLE reset to wrong value: 0x%h", read_data);
           wb_read(DDS_SRC, read_data);
           if(!(read_data[1:0] === 2'b00)) $display("ERROR: DDS_SRC reset to wrong value: 0x%h", read_data);
           wb_read(TUNING_WORD, read_data);
           if(!(read_data[7:0] === 8'h00)) $display("ERROR: TUNING_WORD reset to wrong value: 0x%h", read_data);
           wb_read(GAIN_WORD, read_data);
           if(!(read_data[1:0] === 2'b00)) $display("ERROR: GAIN_WORD reset to wrong value: 0x%h", read_data);
           wb_read(OFFSET_WORD, read_data);
           if(!(read_data[15:0] === 16'h0000)) $display("ERROR: OFFSET_WORD reset to wrong value: 0x%h", read_data);
        end
     endtask // run_reg_test


     integer rand_1;
     integer rand_2;
     task randomize_test();
        begin
           // Randomize Test Environment and Print It To Log
           rand_1         = $urandom(seed);
           rand_2         = $urandom(seed);
           //dds_src_tb     = {30'd0, rand_1[1:0]};
           //tuning_word_tb = {24'd0, rand_2[23:16]};
           //gain_word_tb   = {30'd0, rand_1[3:2]};
           //offset_word_tb = {16'd0, rand_2[15:0]};

           // Temp Overrides
           dds_src_tb     = {30'd0, 2'b00};
           tuning_word_tb = {24'd0, 7'h01};
           gain_word_tb   = {30'd0, 2'b00};
           offset_word_tb = 16'h7fff;

           $display("---------------------------------------------------------------------------");
           case(dds_src_tb[1:0])
              2'b00 : $display("INFO: DDS_SRC: SINE");
              2'b01 : $display("INFO: DDS_SRC: SAW");
              2'b10 : $display("INFO: DDS_SRC: TRI");
              2'b11 : $display("INFO: DDS_SRC: RAND");
           endcase // case (dds_src_tb[1:0])
           $display("INFO: TUNING_WORD 0x%h", tuning_word_tb[7:0]);
           case(gain_word_tb[1:0])
              2'b00 : $display("INFO GAIN_WORD: x1");
              2'b01 : $display("INFO GAIN_WORD: x2");
              2'b10 : $display("INFO GAIN_WORD: x4");
              2'b11 : $display("INFO GAIN_WORD: x8");
           endcase
           $display("INFO: OFFSET_WORD 0x%h", offset_word_tb[15:0]);
           $display("---------------------------------------------------------------------------");
        end
     endtask // randomize_test

     task run_wave_test();
        begin
           wb_write(DDS_SRC, dds_src_tb);
           wb_write(TUNING_WORD, tuning_word_tb);
           wb_write(GAIN_WORD, gain_word_tb);
           wb_write(OFFSET_WORD, offset_word_tb);
           wb_write(ENABLE, 32'd1);
           for(sample_cntr = 0; sample_cntr < 500 ; sample_cntr++) begin
              @ (posedge dds_clk_i_tb) $display("INFO: sample:%d value:%d", sample_cntr, wave_o_tb);
           end
        end
     endtask // run_test

  endmodule // simple_dds_tb
#+end_src
** Python
plot_results.py
#+begin_src python
  #!/bin/usr/python3

  import re
  import glob
  import os
  from matplotlib import pyplot as plt

  values = []
  list_of_files = glob.glob('/home/patrick/ws/school/verilog_and_vhdl/simple_dds/sim/rtl_sim/log/simple_dds*') # * means all if need specific format then *.csv
  latest_file = max(list_of_files, key=os.path.getctime)
  print("Graphing " + latest_file)


  regex = re.compile("value:.*")
  with open(latest_file) as f:
      for line in f:
          result = regex.search(line);
          if result is not None:
              print(result.group(0))
              print(result.group(0)[6:].lstrip())
              values.append(int(result.group(0)[6:].lstrip()))


  plt.plot(values)
  plt.xlabel("Sample")
  plt.ylabel("Value")
  plt.title("Simple DDS Output")
  plt.savefig("plot.png")
  plt.show()
#+end_src
** Makefile
Makefile
#+begin_src makefile
  # Makefile for the simple_dds core. Handles testbench and linting.
  # Author: Patrick Hoey


  SHELL=bash
  CC=iverilog
  CCR=vvp

  RTL_FOLDER=$(shell cd ../../rtl/verilog; pwd)
  TB_FOLDER=$(shell cd ./src; pwd)
  SW_FOLDER=$(shell cd ../../sw; pwd)


  all: simple_dds

  lint_all: lint_simple_dds

  lint_simple_dds:
  @verilator --lint-only --Wall $(RTL_FOLDER)/simple_dds && echo "LINT: OK"

  simple_dds:
  @$(CC) -o ./run/simple_dds.tb $(TB_FOLDER)/simple_dds_tb.v $(RTL_FOLDER)/simple_dds.v $(RTL_FOLDER)/dds_core.v $(RTL_FOLDER)/sine_lut.v $(RTL_FOLDER)/tri_lut.v $(RTL_FOLDER)/saw_lut.v $(RTL_FOLDER)/lfsr.v;
  @cd ./run && $(CCR) simple_dds.tb | tee ../log/simple_dds_log_$$(date +%Y%m%d%H%M%S).tb;

  wave_simple_dds: simple_dds
  @gtkwave out/wave_simple_dds.vcd

  plot_simple_dds: simple_dds
  @python3 $(SW_FOLDER)/plot_results.py

  lint_lfsr:
  @verilator --lint-only --Wall $(RTL_FOLDER)/lfsr && echo "LINT: OK"

  lfsr:
  @$(CC) -o ./run/lfsr.tb $(TB_FOLDER)/lfsr_tb.v $(RTL_FOLDER)/lfsr.v
  @cd ./run && $(CCR) lfsr.tb | tee ../log/lfsr_log_$$(date +%Y%m%d%H%M%S).tb;

  wave_lfsr: lfsr
  @gtkwave out/wave_lfsr.vcd



  clean:
  @rm -rf log/*.tb log/*.vcd
  @rm -rf run/*.tb run/*.vcd
  @rm -rf out/*.tb out/*.vcd
#+end_src

